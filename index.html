<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shape-Shifting Puzzle Animation</title>
    <style>
/* Light/Dark Mode */
body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    transition: background-color 0.3s ease;
}

body.light-mode {
    background-color: #f5f5f5;
}

body.dark-mode {
    background-color: #000000; /* Midnight black */
}

.hero-visual-container {
    position: relative;
    width: 100%;
    height: 100vh;
    overflow: hidden;
    transition: background 0.3s ease;
    /* Exclude settings area from canvas with buffer */
    padding-top: 140px; /* 120px settings + 20px buffer */
    padding-left: 20px;
    padding-right: 20px;
    padding-bottom: 20px;
    box-sizing: border-box;
}

@media (max-width: 768px) {
    .hero-visual-container {
        padding-top: 250px; /* 200px settings + 20px buffer */
        padding-left: 10px;
        padding-right: 10px;
        padding-bottom: 10px;
    }
}

body.light-mode .hero-visual-container {
    /* background: linear-gradient(135deg, #e0e0e0 0%, #f5f5f5 100%); */
    background: #E7E6E5;
}

body.dark-mode .hero-visual-container {
    background: #242526; /* Midnight black */
}

/* Theme Toggle Button */
.theme-toggle {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.9);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}

body.dark-mode .theme-toggle {
    background: rgba(0, 0, 0, 0.8);
    border-color: rgba(255, 255, 255, 0.3);
    color: #FFD700; /* Gold for sun */
}

body.light-mode .theme-toggle {
    background: rgba(255, 255, 255, 0.9);
    color: #1a1a1a; /* Dark for moon */
}

.theme-toggle:hover {
    transform: scale(1.1);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}


body.dark-mode label {
    color: white;
}

body.light-mode label {
    color: #1a1a1a;
}

/* Settings Container - Responsive */
.settings-container {
    position: fixed;
    top: 20px;
    left: 20px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: center;
    max-width: 100%;
    padding: 10px;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(10px);
}

body.dark-mode .settings-container {
    background: rgba(0, 0, 0, 0.9);
}

.settings-container > div {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 8px;
}

.settings-container label {
    font-size: 14px;
    white-space: nowrap;
    margin: 0;
}

.settings-container select,
.settings-container input {
    padding: 6px 10px;
    font-size: 14px;
    border-radius: 6px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.9);
    cursor: pointer;
    min-width: 80px;
}

body.dark-mode .settings-container select,
body.dark-mode .settings-container input {
    background: rgba(0, 0, 0, 0.8);
    border-color: rgba(255, 255, 255, 0.3);
    color: white;
}

body.light-mode .settings-container select,
body.light-mode .settings-container input {
    background: rgba(255, 255, 255, 0.9);
    color: #1a1a1a;
}

.settings-container button {
    padding: 6px 10px;
    font-size: 14px;
    border-radius: 6px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    background: rgba(255, 255, 255, 0.9);
    cursor: pointer;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

body.dark-mode .settings-container button {
    background: rgba(0, 0, 0, 0.8);
    border-color: rgba(255, 255, 255, 0.3);
    color: white;
}

body.light-mode .settings-container button {
    background: rgba(255, 255, 255, 0.9);
    color: #1a1a1a;
}

#seedInput {
    width: 100px;
}

/* Mobile Responsive */
@media (max-width: 768px) {
    .settings-container {
        top: 10px;
        left: 10px;
        right: 10px;
        gap: 8px;
        padding: 8px;
        flex-direction: column;
        align-items: stretch;
    }
    
    .settings-container > div {
        flex-direction: row;
        justify-content: space-between;
        width: 100%;
        gap: 8px;
    }
    
    .settings-container label {
        font-size: 12px;
        flex: 0 0 auto;
        min-width: 80px;
    }
    
    .settings-container select,
    .settings-container input {
        flex: 1;
        min-width: 0;
        font-size: 14px;
        padding: 8px;
    }
    
    #seedInput {
        flex: 1;
        width: auto;
    }
    
    .settings-container button {
        flex: 0 0 auto;
        padding: 8px 12px;
    }
    
    .theme-toggle {
        top: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        font-size: 20px;
    }
}

/* Canvas Cards - Adaptive Sizing */
.canvas-card {
    position: absolute;
    border-radius: 8px;
    padding: 0;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);

    /* Smooth transition for puzzle movement AND resizing */
    transition: top 0.8s cubic-bezier(0.2, 0.8, 0.2, 1),
        left 0.8s cubic-bezier(0.2, 0.8, 0.2, 1),
        width 0.8s cubic-bezier(0.2, 0.8, 0.2, 1),
        height 0.8s cubic-bezier(0.2, 0.8, 0.2, 1),
        transform 0.8s cubic-bezier(0.2, 0.8, 0.2, 1),
        opacity 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
    will-change: top, left, width, height, transform;
    z-index: 10;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* Striped patterns - use mask to create transparent gaps */
.canvas-card.striped-horizontal {
    mask-image: repeating-linear-gradient(
        0deg,
        black 0px,
        black 10px,
        transparent 10px,
        transparent 20px
    );
    -webkit-mask-image: repeating-linear-gradient(
        0deg,
        black 0px,
        black 10px,
        transparent 10px,
        transparent 20px
    );
}

.canvas-card.striped-horizontal-offset {
    mask-image: repeating-linear-gradient(
        0deg,
        transparent 0px,
        transparent 10px,
        black 10px,
        black 20px
    );
    -webkit-mask-image: repeating-linear-gradient(
        0deg,
        transparent 0px,
        transparent 10px,
        black 10px,
        black 20px
    );
}

.canvas-card.striped-vertical {
    mask-image: repeating-linear-gradient(
        90deg,
        black 0px,
        black 10px,
        transparent 10px,
        transparent 20px
    );
    -webkit-mask-image: repeating-linear-gradient(
        90deg,
        black 0px,
        black 10px,
        transparent 10px,
        transparent 20px
    );
}

.canvas-card.striped-vertical-offset {
    mask-image: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 10px,
        black 10px,
        black 20px
    );
    -webkit-mask-image: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 10px,
        black 10px,
        black 20px
    );
}

/* Micro stripes - 1/2 width (5px stripes, 5px gaps, 10px repeat) */
.canvas-card.striped-micro-horizontal {
    mask-image: repeating-linear-gradient(
        0deg,
        black 0px,
        black 5px,
        transparent 5px,
        transparent 10px
    );
    -webkit-mask-image: repeating-linear-gradient(
        0deg,
        black 0px,
        black 5px,
        transparent 5px,
        transparent 10px
    );
}

.canvas-card.striped-micro-horizontal-offset {
    mask-image: repeating-linear-gradient(
        0deg,
        transparent 0px,
        transparent 5px,
        black 5px,
        black 10px
    );
    -webkit-mask-image: repeating-linear-gradient(
        0deg,
        transparent 0px,
        transparent 5px,
        black 5px,
        black 10px
    );
}

.canvas-card.striped-micro-vertical {
    mask-image: repeating-linear-gradient(
        90deg,
        black 0px,
        black 5px,
        transparent 5px,
        transparent 10px
    );
    -webkit-mask-image: repeating-linear-gradient(
        90deg,
        black 0px,
        black 5px,
        transparent 5px,
        transparent 10px
    );
}

.canvas-card.striped-micro-vertical-offset {
    mask-image: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 5px,
        black 5px,
        black 10px
    );
    -webkit-mask-image: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 5px,
        black 5px,
        black 10px
    );
}

/* Macro stripes - 2x width (20px stripes, 20px gaps, 40px repeat) */
.canvas-card.striped-macro-horizontal {
    mask-image: repeating-linear-gradient(
        0deg,
        black 0px,
        black 20px,
        transparent 20px,
        transparent 40px
    );
    -webkit-mask-image: repeating-linear-gradient(
        0deg,
        black 0px,
        black 20px,
        transparent 20px,
        transparent 40px
    );
}

.canvas-card.striped-macro-horizontal-offset {
    mask-image: repeating-linear-gradient(
        0deg,
        transparent 0px,
        transparent 20px,
        black 20px,
        black 40px
    );
    -webkit-mask-image: repeating-linear-gradient(
        0deg,
        transparent 0px,
        transparent 20px,
        black 20px,
        black 40px
    );
}

.canvas-card.striped-macro-vertical {
    mask-image: repeating-linear-gradient(
        90deg,
        black 0px,
        black 20px,
        transparent 20px,
        transparent 40px
    );
    -webkit-mask-image: repeating-linear-gradient(
        90deg,
        black 0px,
        black 20px,
        transparent 20px,
        transparent 40px
    );
}

.canvas-card.striped-macro-vertical-offset {
    mask-image: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 20px,
        black 20px,
        black 40px
    );
    -webkit-mask-image: repeating-linear-gradient(
        90deg,
        transparent 0px,
        transparent 20px,
        black 20px,
        black 40px
    );
}

/* Shape Classes */
.shape-square {
    width: 100px;
    height: 100px;
}

.shape-wide {
    width: 210px;
    height: 100px;
}

.shape-tall {
    width: 100px;
    height: 210px;
}

.shape-big {
    width: 210px;
    height: 210px;
}


/* ABSTRACT WIDGET STYLES - Color Palette */

.card-1 {
    background-color: #C97F7C;
}

.card-2 {
    background-color: #9C5551;
}

.card-3 {
    background-color: #D1923E;
}

.card-4 {
    background-color: #DFC270;
}

.card-5 {
    background-color: #6F8D68;
}

.card-6 {
    background-color: #669EA3;
}

.card-7 {
    background-color: #5B7D93;
}

.card-8 {
    background-color: #9D6EC2;
}

.card-9 {
    background-color: #EBE1CE;
}

.card-10 {
    background-color: #4F4643;
}
    </style>
</head>
<body class="light-mode">
    <div class="settings-container">
        <div>
            <label for="cardCount">Number of Cards:</label>
            <select id="cardCount">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5" selected>5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
            </select>
        </div>
        <div>
            <label for="layerCount">Layers:</label>
            <select id="layerCount">
                <option value="1" selected>1</option>
                <option value="2">2</option>
            </select>
        </div>
        <div>
            <label for="fillMode">Fill:</label>
            <select id="fillMode">
                <option value="solid" selected>Solid</option>
                <option value="striped">Striped</option>
                <option value="micro-striped">Micro Stripes</option>
                <option value="macro-striped">Macro Stripes</option>
                <option value="varied-striped">Varied Stripes</option>
            </select>
        </div>
        <div>
            <label for="paletteSelect">Palette:</label>
            <select id="paletteSelect">
                <option value="default" selected>Default</option>
                <option value="sunset blvd">Sunset Blvd</option>
                <option value="berry">Berry</option>
                <option value="nightshade">Nightshade</option>
            </select>
        </div>
        <div>
            <label for="seedInput">Seed:</label>
            <input type="text" id="seedInput" placeholder="Random">
            <button id="shuffleSeed">ðŸŽ²</button>
        </div>
    </div>
    <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
        <span id="themeIcon">ðŸŒ™</span>
    </button>
    <div class="hero-visual-container">
    </div>

    <script>
// Seeded Random Number Generator
class SeededRandom {
    constructor(seed) {
        this.seed = seed;
    }
    
    // Generate a hash from a string seed
    static hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return Math.abs(hash);
    }
    
    // Initialize with seed (can be number or string)
    setSeed(seed) {
        if (typeof seed === 'string') {
            this.seed = SeededRandom.hashString(seed);
        } else {
            this.seed = Math.abs(Math.floor(seed)) || 1;
        }
    }
    
    // Generate next random number (0 to 1)
    random() {
        this.seed = (this.seed * 9301 + 49297) % 233280;
        return this.seed / 233280;
    }
    
    // Generate random integer between min (inclusive) and max (exclusive)
    randomInt(min, max) {
        return Math.floor(this.random() * (max - min)) + min;
    }
}

// Initialize seed from URL hash or generate random
function getInitialSeed() {
    const hash = window.location.hash.slice(1);
    if (hash) {
        // Try to parse as number first, otherwise use as string
        const numSeed = parseInt(hash);
        return isNaN(numSeed) ? hash : numSeed;
    }
    // Generate random seed
    return Math.floor(Math.random() * 1000000);
}

// Create global seeded RNG instance
let seededRNG = new SeededRandom(getInitialSeed());
let currentSeed = getInitialSeed();

// Update URL hash with seed
function updateSeedHash(seed) {
    window.location.hash = seed.toString();
}

// Shape-Shifting Puzzle Animation
const canvasContainer = document.querySelector('.hero-visual-container');
const cardCountSelect = document.getElementById('cardCount');
const layerCountSelect = document.getElementById('layerCount');
const fillModeSelect = document.getElementById('fillMode');
const paletteSelect = document.getElementById('paletteSelect');
const seedInput = document.getElementById('seedInput');
const shuffleSeedBtn = document.getElementById('shuffleSeed');
const themeToggle = document.getElementById('themeToggle');
const themeIcon = document.getElementById('themeIcon');
let cards = []; // Array of arrays: [layer0Cards, layer1Cards]
let currentInventories = []; // Array of inventories for each layer
let cardStripeDirections = []; // Array of arrays storing stripe directions for each card
let cardOffsetDecisions = []; // Array storing whether to apply offset when layers match (per card index)
let cardStripeTypes = []; // Array of arrays storing stripe types for each card (normal, micro, macro) for varied mode
let isOrganized = false;
let currentScale = 1; // Current scale factor for the layout
let autoCycleInterval;

// Theme Toggle Functionality
function initTheme() {
    // Check for saved theme preference or default to light mode
    const savedTheme = localStorage.getItem('theme') || 'light';
    setTheme(savedTheme);
}

function setTheme(theme) {
    document.body.className = theme === 'dark' ? 'dark-mode' : 'light-mode';
    themeIcon.textContent = theme === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';
    localStorage.setItem('theme', theme);
}

function toggleTheme() {
    const currentTheme = document.body.classList.contains('dark-mode') ? 'dark' : 'light';
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
    setTheme(newTheme);
}

// Initialize theme on page load
initTheme();

// Add event listener for theme toggle button
themeToggle.addEventListener('click', (e) => {
    e.stopPropagation(); // Prevent triggering window click handler
    toggleTheme();
});

// Color palette - all available colors
// Color palettes
const palettes = {
    'default': [
        '#C97F7C', '#9C5551', '#D1923E', '#DFC270', '#6F8D68',
        '#669EA3', '#5B7D93', '#9D6EC2', '#EBE1CE', '#4F4643'
    ],
    'sunset blvd': [
        '#003f5c', '#58508d', '#8a508f', '#bc5090', '#de5a79',
        '#ff6361', '#ff8531', '#ffa600'
    ],
    'berry': [
        '#c45161', '#e094a0', '#f2b6c0', '#f2dde1', '#cbc7d8',
        '#8db7d2', '#5e62a9', '#434279'
    ],
    'nightshade': [
        '#440834', '#871067', '#a54983', '#c3819e', '#e1bab9',
        '#fff2d4', '#b5b9a7', '#6a8079'
    ]
};

// Function to apply stripes to cards
function applyStripes(scale = 1) {
    const fillMode = fillModeSelect.value;
    const numLayers = parseInt(layerCountSelect.value);
    
    // Check if any stripe mode is active
    const isStripeMode = fillMode === 'striped' || fillMode === 'micro-striped' || 
                        fillMode === 'macro-striped' || fillMode === 'varied-striped';
    
    cards.forEach((layerCards, layerIndex) => {
        layerCards.forEach((card, cardIndex) => {
            // Remove all stripe classes
            card.classList.remove(
                'striped-horizontal', 'striped-horizontal-offset', 
                'striped-vertical', 'striped-vertical-offset',
                'striped-micro-horizontal', 'striped-micro-horizontal-offset',
                'striped-micro-vertical', 'striped-micro-vertical-offset',
                'striped-macro-horizontal', 'striped-macro-horizontal-offset',
                'striped-macro-vertical', 'striped-macro-vertical-offset'
            );
            
            // Clear any existing stripe mask images
            card.style.maskImage = '';
            card.style.webkitMaskImage = '';
            
            if (isStripeMode) {
                const stripeDirection = cardStripeDirections[layerIndex]?.[cardIndex];
                if (stripeDirection) {
                    // Determine stripe type based on fill mode
                    let stripeType = 'normal';
                    if (fillMode === 'varied-striped') {
                        stripeType = cardStripeTypes[layerIndex]?.[cardIndex] || 'normal';
                    } else if (fillMode === 'micro-striped') {
                        stripeType = 'micro';
                    } else if (fillMode === 'macro-striped') {
                        stripeType = 'macro';
                    }
                    
                    // Calculate scaled stripe sizes
                    let stripeSize, repeatSize;
                    if (stripeType === 'micro') {
                        stripeSize = 5 * scale;   // 5px scaled
                        repeatSize = 10 * scale; // 10px repeat scaled
                    } else if (stripeType === 'macro') {
                        stripeSize = 20 * scale; // 20px scaled
                        repeatSize = 40 * scale; // 40px repeat scaled
                    } else {
                        stripeSize = 10 * scale; // 10px scaled
                        repeatSize = 20 * scale; // 20px repeat scaled
                    }
                    
                    // Always offset bottom layer in striped modes (for interleaving)
                    const shouldOffset = numLayers === 2 && layerIndex === 1;
                    
                    // Build mask-image with scaled values
                    const angle = stripeDirection === 'horizontal' ? '0deg' : '90deg';
                    let maskImage;
                    
                    if (shouldOffset) {
                        // Offset pattern: transparent first, then stripe
                        maskImage = `repeating-linear-gradient(${angle}, transparent 0px, transparent ${stripeSize}px, black ${stripeSize}px, black ${repeatSize}px)`;
                    } else {
                        // Normal pattern: stripe first, then transparent
                        maskImage = `repeating-linear-gradient(${angle}, black 0px, black ${stripeSize}px, transparent ${stripeSize}px, transparent ${repeatSize}px)`;
                    }
                    
                    card.style.maskImage = maskImage;
                    card.style.webkitMaskImage = maskImage;
                }
            }
        });
    });
}

// Function to create/update cards based on selected count and layers
function updateCardElements(numCards, numLayers) {
    // Clear existing cards
    canvasContainer.innerHTML = '';
    cards = [];
    currentInventories = [];
    cardStripeDirections = [];
    cardOffsetDecisions = [];
    cardStripeTypes = [];
    
    // Create cards for each layer
    for (let layer = 0; layer < numLayers; layer++) {
        const layerCards = [];
        const layerStripeDirections = [];
        const layerStripeTypes = [];
        
        // Get the selected palette
        const selectedPaletteName = paletteSelect.value;
        const colorPalette = palettes[selectedPaletteName] || palettes['default'];
        
        // Randomly select colors from palette (each color used only once per layer)
        const shuffledPalette = [...colorPalette].sort(() => seededRNG.random() - 0.5);
        const selectedColors = shuffledPalette.slice(0, numCards);
        
        // Shuffle the selected colors again to assign randomly to cards
        const assignedColors = [...selectedColors].sort(() => seededRNG.random() - 0.5);
        
        // Create new cards with randomly assigned colors
        for (let i = 0; i < numCards; i++) {
            const card = document.createElement('div');
            // Use inline style for background color to support any palette
            card.className = `canvas-card layer-${layer}`;
            card.style.backgroundColor = assignedColors[i];
            // Store the card's original index for later reference
            card.dataset.cardIndex = i;
            // Layer 0 (top) has higher z-index, layer 1 (bottom) has lower z-index
            card.style.zIndex = numLayers - layer;
            
            // Set opacity based on number of layers
            if (numLayers === 1) {
                card.style.opacity = '1.0'; // Full opacity for single layer
            } else if (numLayers === 2) {
                if (layer === 0) {
                    card.style.opacity = '0.95'; // Top layer: 33% opacity
                } else {
                    card.style.opacity = '1'; // Bottom layer: 66% opacity
                }
            }
            
            // Randomly assign stripe direction (50/50 chance for horizontal/vertical)
            const stripeDirection = seededRNG.random() < 0.5 ? 'horizontal' : 'vertical';
            layerStripeDirections.push(stripeDirection);
            
            // For varied mode, assign random stripe type to each card (normal, micro, or macro)
            // For other modes, stripe type will be determined by fillMode
            const fillMode = fillModeSelect.value;
            let stripeType = 'normal'; // default
            if (fillMode === 'varied-striped') {
                const rand = seededRNG.random();
                if (rand < 0.333) {
                    stripeType = 'micro';
                } else if (rand < 0.666) {
                    stripeType = 'macro';
                } else {
                    stripeType = 'normal';
                }
            } else if (fillMode === 'micro-striped') {
                stripeType = 'micro';
            } else if (fillMode === 'macro-striped') {
                stripeType = 'macro';
            }
            layerStripeTypes.push(stripeType);
            
            canvasContainer.appendChild(card);
            layerCards.push(card);
        }
        
        cards.push(layerCards);
        cardStripeDirections.push(layerStripeDirections);
        cardStripeTypes.push(layerStripeTypes);
    }
    
    // Determine offset decisions for each card when both layers have matching stripe directions
    if (numLayers === 2) {
        for (let i = 0; i < numCards; i++) {
            const topDirection = cardStripeDirections[0]?.[i];
            const bottomDirection = cardStripeDirections[1]?.[i];
            
            // If both layers have the same stripe direction, decide whether to offset (85% chance)
            if (topDirection && bottomDirection && topDirection === bottomDirection) {
                cardOffsetDecisions[i] = seededRNG.random() < 0.85; // 85% chance of offset
            } else {
                cardOffsetDecisions[i] = false; // No offset if directions don't match
            }
        }
    }
    
    // Apply stripes if needed (use current scale if organized, otherwise 1)
    applyStripes(isOrganized ? currentScale : 1);
}

if (canvasContainer) {

    // Dynamic Unit Size
    function getUnitSize() {
        return window.innerWidth < 768 ? 60 : 100;
    }

    const GAP = 20;



    // Dynamic Layout Generator (Perfect Rectangles with Bitmask Optimization)
    function generateRandomLayout(numCards) {
        // All shape types up to 4x4
        const shapeTypes = [
            'shape-square',      // 1x1
            'shape-wide',        // 2x1
            'shape-tall',        // 1x2
            'shape-big',         // 2x2
            'shape-wide-3',      // 3x1
            'shape-tall-3',      // 1x3
            'shape-wide-4',      // 4x1
            'shape-tall-4',      // 1x4
            'shape-rect-3x2',    // 3x2
            'shape-rect-2x3',    // 2x3
            'shape-big-3x3',     // 3x3
            'shape-rect-4x2',    // 4x2
            'shape-rect-2x4',    // 2x4
            'shape-rect-4x3',    // 4x3
            'shape-rect-3x4',    // 3x4
            'shape-big-4x4'      // 4x4
        ];
        const shapeDims = {
            'shape-square': { w: 1, h: 1 },
            'shape-wide': { w: 2, h: 1 },
            'shape-tall': { w: 1, h: 2 },
            'shape-big': { w: 2, h: 2 },
            'shape-wide-3': { w: 3, h: 1 },
            'shape-tall-3': { w: 1, h: 3 },
            'shape-wide-4': { w: 4, h: 1 },
            'shape-tall-4': { w: 1, h: 4 },
            'shape-rect-3x2': { w: 3, h: 2 },
            'shape-rect-2x3': { w: 2, h: 3 },
            'shape-big-3x3': { w: 3, h: 3 },
            'shape-rect-4x2': { w: 4, h: 2 },
            'shape-rect-2x4': { w: 2, h: 4 },
            'shape-rect-4x3': { w: 4, h: 3 },
            'shape-rect-3x4': { w: 3, h: 4 },
            'shape-big-4x4': { w: 4, h: 4 }
        };

        // Precompute bitmasks for all shapes at all valid positions in a 5x5 grid
        // Grid is represented as a 25-bit BigInt (0-24), row-major order.
        // (0,0) is bit 0, (4,4) is bit 24.
        const SHAPE_MASKS = {};

        function getMask(w, h, x, y) {
            let mask = BigInt(0);
            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {
                    const bitIndex = (y + dy) * 5 + (x + dx);
                    mask |= (BigInt(1) << BigInt(bitIndex));
                }
            }
            return mask;
        }

        shapeTypes.forEach(type => {
            SHAPE_MASKS[type] = [];
            const { w, h } = shapeDims[type];
            // Store masks for all possible top-left positions (x,y)
            // Note: We compute for the full 5x5 grid.
            // When solving for smaller WxH, we just ensure we don't pick positions outside WxH.
            for (let y = 0; y <= 5 - h; y++) {
                for (let x = 0; x <= 5 - w; x++) {
                    SHAPE_MASKS[type].push({
                        x, y,
                        mask: getMask(w, h, x, y)
                    });
                }
            }
        });

        // Helper: Check if a set of shapes can form a rectangle of size WxH
        function solveTiling(shapes, W, H) {
            // Target mask: The rectangle WxH must be filled.
            // Our bitmask system is 5x5, so we define the "boundary" by only allowing positions within WxH.

            // Sort shapes largest to smallest to speed up backtracking
            const sortedShapes = [...shapes].sort((a, b) => {
                const areaA = shapeDims[a].w * shapeDims[a].h;
                const areaB = shapeDims[b].w * shapeDims[b].h;
                return areaB - areaA;
            });

            const layout = []; // Stores {x, y, shape}

            function backtrack(index, currentMask) {
                if (index === sortedShapes.length) return true;

                const shape = sortedShapes[index];
                const { w, h } = shapeDims[shape];

                // Try all valid positions for this shape within WxH
                // We use the precomputed masks, but filter by W and H limits
                const possibleMoves = SHAPE_MASKS[shape];

                for (let i = 0; i < possibleMoves.length; i++) {
                    const move = possibleMoves[i];

                    // Check bounds for current target rectangle WxH
                    if (move.x + w > W || move.y + h > H) continue;

                    // Check collision using Bitwise AND (BigInt)
                    if ((currentMask & move.mask) === BigInt(0)) {
                        // Place shape
                        layout.push({ x: move.x, y: move.y, shape: shape });

                        // Recurse with updated mask (Bitwise OR)
                        if (backtrack(index + 1, currentMask | move.mask)) return true;

                        // Backtrack
                        layout.pop();
                    }
                }
                return false;
            }

            if (backtrack(0, BigInt(0))) {
                return layout;
            }
            return null;
        }

        let attempts = 0;
        while (attempts < 5000) {
            attempts++;

            // 1. Pick numCards random shapes
            const shapes = [];
            let totalArea = 0;
            for (let i = 0; i < numCards; i++) {
                const shape = shapeTypes[Math.floor(seededRNG.random() * shapeTypes.length)];
                shapes.push(shape);
                totalArea += shapeDims[shape].w * shapeDims[shape].h;
            }

            // 2. Find valid rectangular dimensions for this area
            // Max area is numCards * 16 (for 4x4 shapes), but max grid is 25
            // We only care if area <= 25
            if (totalArea > 25) continue;

            const validDims = [];
            // Find factors of totalArea that fit in 5x5
            for (let w = 1; w <= 5; w++) {
                if (totalArea % w === 0) {
                    const h = totalArea / w;
                    if (h <= 5) {
                        validDims.push({ w, h });
                    }
                }
            }

            if (validDims.length === 0) continue;

            // Pick a random valid dimension
            const dim = validDims[Math.floor(seededRNG.random() * validDims.length)];

            // 3. Try to tile
            const resultLayout = solveTiling(shapes, dim.w, dim.h);

            if (resultLayout) {
                // Success!

                // Randomly flip the layout to simulate packing from different corners
                // Since the solver always packs Top-Left to Bottom-Right, big shapes tend to be at TL.
                // Flipping allows them to be at TR, BL, or BR.
                const flipX = seededRNG.random() > 0.5;
                const flipY = seededRNG.random() > 0.5;

                if (flipX || flipY) {
                    resultLayout.forEach(item => {
                        const { w, h } = shapeDims[item.shape];
                        if (flipX) {
                            item.x = dim.w - item.x - w;
                        }
                        if (flipY) {
                            item.y = dim.h - item.y - h;
                        }
                    });
                }

                // Extract shapes from the result layout to ensure exact match
                // We shuffle them to ensure that specific cards (like card[0]) don't always get the big shapes
                // which happens because the solver sorts by size.
                const finalShapes = resultLayout.map(l => l.shape).sort(() => seededRNG.random() - 0.5);

                return {
                    name: `Rectangular ${dim.w}x${dim.h}`,
                    shapes: finalShapes,
                    layout: resultLayout
                };
            }
        }

        // Fallback - create a simple grid layout
        const fallbackShapes = Array(numCards).fill('shape-square');
        const fallbackLayout = [];
        const fallbackWidth = Math.ceil(Math.sqrt(numCards));
        for (let i = 0; i < numCards; i++) {
            const x = i % fallbackWidth;
            const y = Math.floor(i / fallbackWidth);
            fallbackLayout.push({ x, y, shape: 'shape-square' });
        }
        
        return {
            name: "Fallback Square",
            shapes: fallbackShapes,
            layout: fallbackLayout
        };
    }

    function setCardShapes(inventories) {
        // Process each layer's inventory
        inventories.forEach((inventory, layerIndex) => {
            const shapes = inventory.shapes;
            const UNIT = getUnitSize();
            const layerCards = cards[layerIndex] || [];

            const allShapeClasses = [
                'shape-square', 'shape-wide', 'shape-tall', 'shape-big',
                'shape-wide-3', 'shape-tall-3', 'shape-wide-4', 'shape-tall-4',
                'shape-rect-3x2', 'shape-rect-2x3', 'shape-big-3x3',
                'shape-rect-4x2', 'shape-rect-2x4', 'shape-rect-4x3',
                'shape-rect-3x4', 'shape-big-4x4'
            ];

            layerCards.forEach((card, i) => {
                if (i < shapes.length) {
                    // Remove all shape classes
                    card.classList.remove(...allShapeClasses);
                    card.classList.add(shapes[i]);
                    card.dataset.shape = shapes[i];

                    // Explicitly set size based on current UNIT
                    let w, h;
                    switch (shapes[i]) {
                        case 'shape-square': w = UNIT; h = UNIT; break;
                        case 'shape-wide': w = UNIT * 2 + GAP; h = UNIT; break;
                        case 'shape-tall': w = UNIT; h = UNIT * 2 + GAP; break;
                        case 'shape-big': w = UNIT * 2 + GAP; h = UNIT * 2 + GAP; break;
                        case 'shape-wide-3': w = UNIT * 3 + GAP * 2; h = UNIT; break;
                        case 'shape-tall-3': w = UNIT; h = UNIT * 3 + GAP * 2; break;
                        case 'shape-wide-4': w = UNIT * 4 + GAP * 3; h = UNIT; break;
                        case 'shape-tall-4': w = UNIT; h = UNIT * 4 + GAP * 3; break;
                        case 'shape-rect-3x2': w = UNIT * 3 + GAP * 2; h = UNIT * 2 + GAP; break;
                        case 'shape-rect-2x3': w = UNIT * 2 + GAP; h = UNIT * 3 + GAP * 2; break;
                        case 'shape-big-3x3': w = UNIT * 3 + GAP * 2; h = UNIT * 3 + GAP * 2; break;
                        case 'shape-rect-4x2': w = UNIT * 4 + GAP * 3; h = UNIT * 2 + GAP; break;
                        case 'shape-rect-2x4': w = UNIT * 2 + GAP; h = UNIT * 4 + GAP * 3; break;
                        case 'shape-rect-4x3': w = UNIT * 4 + GAP * 3; h = UNIT * 3 + GAP * 2; break;
                        case 'shape-rect-3x4': w = UNIT * 3 + GAP * 2; h = UNIT * 4 + GAP * 3; break;
                        case 'shape-big-4x4': w = UNIT * 4 + GAP * 3; h = UNIT * 4 + GAP * 3; break;
                        default: w = UNIT; h = UNIT; break;
                    }
                    card.style.width = `${w}px`;
                    card.style.height = `${h}px`;
                }
            });
        });
    }

    function randomizePositions() {
        isOrganized = false;
        currentScale = 1; // Reset scale for random positions
        const numCards = parseInt(cardCountSelect.value);
        const numLayers = parseInt(layerCountSelect.value);
        
        // Generate a NEW layout for each layer
        currentInventories = [];
        for (let layer = 0; layer < numLayers; layer++) {
            currentInventories.push(generateRandomLayout(numCards));
        }
        setCardShapes(currentInventories);

        // Define zones to ensure distribution - create zones based on number of cards
        // Calculate canvas area (excluding settings and buffer)
        const settingsHeight = window.innerWidth <= 768 ? 200 : 120;
        const bufferHeight = 20; // 20px buffer below settings area
        const canvasTopOffset = settingsHeight + bufferHeight;
        const canvasHeight = window.innerHeight - canvasTopOffset - (window.innerWidth <= 768 ? 10 : 20);
        const canvasCenterY = canvasTopOffset + (canvasHeight / 2);
        
        // Zones are defined as percentages of canvas area, then converted to viewport coordinates
        const baseZones = [
            { x: 25, y: 25 }, // TL (relative to canvas)
            { x: 75, y: 25 }, // TR (relative to canvas)
            { x: 25, y: 75 }, // BL (relative to canvas)
            { x: 75, y: 75 }, // BR (relative to canvas)
            { x: 50, y: 50 },  // Center (relative to canvas)
            { x: 15, y: 50 },  // Left (relative to canvas)
            { x: 85, y: 50 },  // Right (relative to canvas)
            { x: 50, y: 20 },  // Top (relative to canvas)
            { x: 50, y: 80 },  // Bottom (relative to canvas)
            { x: 35, y: 40 }   // Extra (relative to canvas)
        ];
        
        // Use as many zones as we need, up to the number of cards
        const zones = baseZones.slice(0, Math.max(numCards, 5));

        // Process each layer
        const fillMode = fillModeSelect.value;
        const isStriped = fillMode === 'striped';
        
        cards.forEach((layerCards, layerIndex) => {
            // Shuffle zones for each layer
            const shuffledZones = [...zones].sort(() => seededRNG.random() - 0.5);
            
            layerCards.forEach((card, i) => {
                // Assign card to a zone
                const zone = shuffledZones[i % shuffledZones.length];

                // Add random jitter (+/- 10%)
                const jitterX = (seededRNG.random() * 20) - 10;
                const jitterY = (seededRNG.random() * 20) - 10;

                let finalX = zone.x + jitterX;
                let finalY = zone.y + jitterY;

                const randomRotate = seededRNG.random() * 40 - 20;

                // Convert percentage to pixel position within canvas area
                // Zones are defined as percentages of canvas area (not viewport)
                const settingsHeight = window.innerWidth <= 768 ? 200 : 120;
                const bufferHeight = 20; // 20px buffer below settings area
                const canvasTopOffset = settingsHeight + bufferHeight;
                const containerPaddingX = window.innerWidth <= 768 ? 10 : 20;
                const containerPaddingY = window.innerWidth <= 768 ? 10 : 20;
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                // Canvas area dimensions
                const canvasWidth = vw - (containerPaddingX * 2);
                const canvasHeight = vh - canvasTopOffset - containerPaddingY;
                // Convert percentage to pixel position within canvas area
                let pixelX = (finalX / 100) * canvasWidth + containerPaddingX;
                let pixelY = canvasTopOffset + (finalY / 100) * canvasHeight;
                
                if (isStriped) {
                    // Get stripe type for this card to determine grid alignment
                    let stripeType = 'normal';
                    if (fillMode === 'varied-striped') {
                        stripeType = cardStripeTypes[layerIndex]?.[i] || 'normal';
                    } else if (fillMode === 'micro-striped') {
                        stripeType = 'micro';
                    } else if (fillMode === 'macro-striped') {
                        stripeType = 'macro';
                    }
                    
                    // Determine grid size and offset based on stripe type
                    // Align to stripe pattern grid to ensure patterns align across cards
                    let gridSize, offset;
                    if (stripeType === 'micro') {
                        gridSize = 10; // 10px repeat - align to 10px grid
                        offset = 5;    // 5px offset (half of 10px repeat)
                    } else if (stripeType === 'macro') {
                        gridSize = 40; // 40px repeat - align to 40px grid
                        offset = 20;   // 20px offset (half of 40px repeat)
                    } else {
                        gridSize = 20; // 20px repeat - align to 20px grid
                        offset = 10;   // 10px offset (half of 20px repeat)
                    }
                    
                    // Round to nearest grid size to align stripe patterns
                    // This ensures transparent gaps don't create visual spacing issues
                    // Don't offset card positions - only the stripe pattern is offset via CSS classes
                    pixelX = Math.round(pixelX / gridSize) * gridSize;
                    pixelY = Math.round(pixelY / gridSize) * gridSize;
                } else {
                    // For non-striped modes, use 10px grid to preserve spacing
                    pixelX = Math.round(pixelX / 10) * 10;
                    pixelY = Math.round(pixelY / 10) * 10;
                }
                
                // Convert back to percentage of container (not viewport)
                // This ensures cards are positioned relative to the container's content area
                finalX = (pixelX / vw) * 100;
                finalY = (pixelY / vh) * 100;

                card.style.top = `${finalY}%`;
                card.style.left = `${finalX}%`;
                card.style.transform = `translate(-50%, -50%) rotate(${randomRotate}deg)`;
                // Keep layer z-index but add some randomness within layer
                const baseZ = (numLayers - layerIndex) * 10;
                card.style.zIndex = baseZ + Math.floor(seededRNG.random() * 5);
            });
        });
        
        // Apply stripes with scale 1 for random positions
        applyStripes(1);
    }

    function organizePositions() {
        isOrganized = true;
        const UNIT = getUnitSize();
        const numLayers = parseInt(layerCountSelect.value);

        // Shape dimensions for bounding box calculation
        const shapeDims = {
            'shape-square': { w: UNIT, h: UNIT },
            'shape-wide': { w: UNIT * 2 + GAP, h: UNIT },
            'shape-tall': { w: UNIT, h: UNIT * 2 + GAP },
            'shape-big': { w: UNIT * 2 + GAP, h: UNIT * 2 + GAP },
            'shape-wide-3': { w: UNIT * 3 + GAP * 2, h: UNIT },
            'shape-tall-3': { w: UNIT, h: UNIT * 3 + GAP * 2 },
            'shape-wide-4': { w: UNIT * 4 + GAP * 3, h: UNIT },
            'shape-tall-4': { w: UNIT, h: UNIT * 4 + GAP * 3 },
            'shape-rect-3x2': { w: UNIT * 3 + GAP * 2, h: UNIT * 2 + GAP },
            'shape-rect-2x3': { w: UNIT * 2 + GAP, h: UNIT * 3 + GAP * 2 },
            'shape-big-3x3': { w: UNIT * 3 + GAP * 2, h: UNIT * 3 + GAP * 2 },
            'shape-rect-4x2': { w: UNIT * 4 + GAP * 3, h: UNIT * 2 + GAP },
            'shape-rect-2x4': { w: UNIT * 2 + GAP, h: UNIT * 4 + GAP * 3 },
            'shape-rect-4x3': { w: UNIT * 4 + GAP * 3, h: UNIT * 3 + GAP * 2 },
            'shape-rect-3x4': { w: UNIT * 3 + GAP * 2, h: UNIT * 4 + GAP * 3 },
            'shape-big-4x4': { w: UNIT * 4 + GAP * 3, h: UNIT * 4 + GAP * 3 }
        };

        // Calculate maximum bounding box across all layers to determine scale
        let maxLayoutWidth = 0;
        let maxLayoutHeight = 0;
        
        currentInventories.forEach((inventory) => {
            if (!inventory) return;
            let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;
            
            inventory.layout.forEach(slot => {
                const dims = shapeDims[slot.shape];
                const left = slot.x * (UNIT + GAP);
                const top = slot.y * (UNIT + GAP);
                const right = left + dims.w;
                const bottom = top + dims.h;
                
                if (left < minLeft) minLeft = left;
                if (right > maxRight) maxRight = right;
                if (top < minTop) minTop = top;
                if (bottom > maxBottom) maxBottom = bottom;
            });
            
            const layoutWidth = maxRight - minLeft;
            const layoutHeight = maxBottom - minTop;
            if (layoutWidth > maxLayoutWidth) maxLayoutWidth = layoutWidth;
            if (layoutHeight > maxLayoutHeight) maxLayoutHeight = layoutHeight;
        });
        
        // Calculate available space excluding settings area and buffer
        // Settings container takes up space at the top, plus 20px buffer
        const settingsHeight = window.innerWidth <= 768 ? 200 : 120;
        const bufferHeight = 20; // 20px buffer below settings area
        const canvasTopOffset = settingsHeight + bufferHeight;
        const edgeBuffer = 40;
        const availableWidth = window.innerWidth - (edgeBuffer * 2);
        const availableHeight = window.innerHeight - canvasTopOffset - (edgeBuffer * 2);
        
        // Calculate the center of the canvas area (excluding settings)
        // This is where cards will be centered
        const canvasCenterX = window.innerWidth / 2;
        const canvasCenterY = canvasTopOffset + (availableHeight / 2);
        
        // Calculate scale factor to fit layout within available space
        // Only scale down if needed, never scale up
        const scaleX = maxLayoutWidth > 0 ? Math.min(availableWidth / maxLayoutWidth, 1) : 1;
        const scaleY = maxLayoutHeight > 0 ? Math.min(availableHeight / maxLayoutHeight, 1) : 1;
        const scale = Math.min(scaleX, scaleY);

        // Process each layer separately
        cards.forEach((layerCards, layerIndex) => {
            const currentInventory = currentInventories[layerIndex];
            if (!currentInventory) return;

            const cardsByShape = {
                'shape-square': [],
                'shape-wide': [],
                'shape-tall': [],
                'shape-big': [],
                'shape-wide-3': [],
                'shape-tall-3': [],
                'shape-wide-4': [],
                'shape-tall-4': [],
                'shape-rect-3x2': [],
                'shape-rect-2x3': [],
                'shape-big-3x3': [],
                'shape-rect-4x2': [],
                'shape-rect-2x4': [],
                'shape-rect-4x3': [],
                'shape-rect-3x4': [],
                'shape-big-4x4': []
            };

            layerCards.forEach(card => {
                if (cardsByShape[card.dataset.shape]) {
                    cardsByShape[card.dataset.shape].push(card);
                }
            });

            for (let key in cardsByShape) {
                cardsByShape[key].sort(() => seededRNG.random() - 0.5);
            }

            // Calculate visual bounding box of the layout (using Top-Left coordinates)
            let minLeft = Infinity, maxRight = -Infinity, minTop = Infinity, maxBottom = -Infinity;

            currentInventory.layout.forEach(slot => {
                const dims = shapeDims[slot.shape];
                // Coordinates are Top-Left based in the original system
                const left = slot.x * (UNIT + GAP);
                const top = slot.y * (UNIT + GAP);
                const right = left + dims.w;
                const bottom = top + dims.h;

                if (left < minLeft) minLeft = left;
                if (right > maxRight) maxRight = right;
                if (top < minTop) minTop = top;
                if (bottom > maxBottom) maxBottom = bottom;
            });

            // Calculate the center of the bounding box
            const visualCenterX = (minLeft + maxRight) / 2;
            const visualCenterY = (minTop + maxBottom) / 2;

            currentInventory.layout.forEach((slot, slotIndex) => {
                const card = cardsByShape[slot.shape].pop();
                if (card) {
                    // Get the card's original index from data attribute
                    const cardIndex = parseInt(card.dataset.cardIndex) || 0;
                    
                    // Calculate position relative to center
                    // We want the card's Top-Left to be shifted so that the BoundingBox Center aligns with (0,0)
                    let targetX = (slot.x * (UNIT + GAP)) - visualCenterX;
                    let targetY = (slot.y * (UNIT + GAP)) - visualCenterY;
                    
                    // Determine grid size and offset based on stripe type
                    const fillMode = fillModeSelect.value;
                    const isStripeMode = fillMode === 'striped' || fillMode === 'micro-striped' || 
                                       fillMode === 'macro-striped' || fillMode === 'varied-striped';
                    
                    if (isStripeMode) {
                        // Get stripe type for this card to determine grid alignment
                        let stripeType = 'normal';
                        if (fillMode === 'varied-striped') {
                            stripeType = cardStripeTypes[layerIndex]?.[cardIndex] || 'normal';
                        } else if (fillMode === 'micro-striped') {
                            stripeType = 'micro';
                        } else if (fillMode === 'macro-striped') {
                            stripeType = 'macro';
                        }
                        
                        // Determine grid size and offset based on stripe type
                        // Align to stripe pattern grid to ensure patterns align across cards
                        let gridSize, offset;
                        if (stripeType === 'micro') {
                            gridSize = 10; // 10px repeat - align to 10px grid
                            offset = 5;    // 5px offset (half of 10px repeat)
                        } else if (stripeType === 'macro') {
                            gridSize = 40; // 40px repeat - align to 40px grid
                            offset = 20;   // 20px offset (half of 40px repeat)
                        } else {
                            gridSize = 20; // 20px repeat - align to 20px grid
                            offset = 10;   // 10px offset (half of 20px repeat)
                        }
                        
                        // Round to nearest grid size to align stripe patterns
                        // This ensures transparent gaps don't create visual spacing issues
                        // Don't offset card positions - only the stripe pattern is offset via CSS classes
                        targetX = Math.round(targetX / gridSize) * gridSize;
                        targetY = Math.round(targetY / gridSize) * gridSize;
                    } else {
                        // For non-striped modes, use 10px grid to preserve spacing
                        targetX = Math.round(targetX / 10) * 10;
                        targetY = Math.round(targetY / 10) * 10;
                    }
                    
                    // Apply scale to positions
                    targetX *= scale;
                    targetY *= scale;

                    // Position relative to canvas center (not viewport center)
                    // Canvas center is already calculated above
                    card.style.left = `${canvasCenterX + targetX}px`;
                    card.style.top = `${canvasCenterY + targetY}px`;
                    
                    // Apply scale to card sizes
                    const dims = shapeDims[slot.shape];
                    card.style.width = `${dims.w * scale}px`;
                    card.style.height = `${dims.h * scale}px`;
                    // Revert to translate(0,0) to match Top-Left anchoring
                    card.style.transform = `translate(0, 0) rotate(0deg)`;
                    // Set z-index based on layer
                    const baseZ = (numLayers - layerIndex) * 20;
                    card.style.zIndex = baseZ;
                }
            });
        });
        
        // Store the scale for use in applyStripes
        currentScale = scale;
        
        // Apply stripes with the calculated scale
        applyStripes(scale);
    }

    function toggleState() {
        if (isOrganized) {
            randomizePositions();
        } else {
            organizePositions();
        }
    }

    function startAutoCycle() {
        stopAutoCycle(); // Clear existing to be safe
        autoCycleInterval = setInterval(() => {
            toggleState();
        }, 999999);
        // }, 4000);
    }

    function stopAutoCycle() {
        if (autoCycleInterval) {
            clearInterval(autoCycleInterval);
            autoCycleInterval = null;
        }
    }

    // Apply seed-derived settings to UI (only called when seed changes)
    function applySeedSettings() {
        // Reset RNG seed to ensure reproducible results
        seededRNG.setSeed(currentSeed);
        
        // Derive number of cards (1-8) from seed
        const numCards = seededRNG.randomInt(1, 9); // 1 to 8 inclusive
        
        // Derive number of layers (1-2) from seed
        const numLayers = seededRNG.randomInt(1, 3); // 1 to 2 inclusive
        
        // Derive fill mode from seed (5 options)
        const fillModes = ['solid', 'striped', 'micro-striped', 'macro-striped', 'varied-striped'];
        const fillMode = fillModes[seededRNG.randomInt(0, fillModes.length)];
        
        // Derive palette from seed
        const paletteNames = Object.keys(palettes);
        const palette = paletteNames[seededRNG.randomInt(0, paletteNames.length)];
        
        // Update UI to reflect seed-derived settings
        cardCountSelect.value = numCards;
        layerCountSelect.value = numLayers;
        fillModeSelect.value = fillMode;
        paletteSelect.value = palette;
    }

    // Initialization function
    function initialize() {
        // Reset RNG seed to ensure reproducible results
        seededRNG.setSeed(currentSeed);
        
        // Use current dropdown values (not seed-derived, allowing manual changes)
        const numCards = parseInt(cardCountSelect.value);
        const numLayers = parseInt(layerCountSelect.value);
        
        updateCardElements(numCards, numLayers);
        stopAutoCycle();
        randomizePositions();
        startAutoCycle();
    }

    // Event listeners for dropdown changes
    cardCountSelect.addEventListener('change', () => {
        initialize();
    });

    layerCountSelect.addEventListener('change', () => {
        initialize();
    });

    fillModeSelect.addEventListener('change', () => {
        const fillMode = fillModeSelect.value;
        const numLayers = parseInt(layerCountSelect.value);
        const numCards = parseInt(cardCountSelect.value);
        
        // If switching to varied mode, regenerate stripe types for existing cards
        if (fillMode === 'varied-striped' && cards.length > 0) {
            cardStripeTypes = [];
            for (let layer = 0; layer < numLayers; layer++) {
                const layerStripeTypes = [];
                for (let i = 0; i < numCards; i++) {
                    const rand = seededRNG.random();
                    let stripeType = 'normal';
                    if (rand < 0.333) {
                        stripeType = 'micro';
                    } else if (rand < 0.666) {
                        stripeType = 'macro';
                    }
                    layerStripeTypes.push(stripeType);
                }
                cardStripeTypes.push(layerStripeTypes);
            }
        }
        
        // Apply stripes with current scale (use current scale if organized, otherwise 1)
        applyStripes(isOrganized ? currentScale : 1);
    });

    paletteSelect.addEventListener('change', () => {
        // When palette changes, regenerate cards with new colors
        const numCards = parseInt(cardCountSelect.value);
        const numLayers = parseInt(layerCountSelect.value);
        updateCardElements(numCards, numLayers);
        if (isOrganized) {
            organizePositions();
        } else {
            randomizePositions();
        }
    });

    // Seed input initialization and event listener
    seedInput.value = currentSeed.toString();
    seedInput.addEventListener('change', () => {
        const newSeed = seedInput.value.trim();
        if (newSeed === '') {
            // Generate random seed if empty (use Math.random() since we're creating a new seed)
            currentSeed = Math.floor(Math.random() * 1000000);
            seedInput.value = currentSeed.toString();
        } else {
            currentSeed = newSeed;
        }
        updateSeedHash(currentSeed);
        // Apply seed-derived settings when seed changes
        applySeedSettings();
        initialize();
    });

    // Shuffle seed button event listener
    shuffleSeedBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent triggering window click
        // Generate new random seed (use Math.random() since we're creating a new seed)
        currentSeed = Math.floor(Math.random() * 1000000);
        seedInput.value = currentSeed.toString();
        updateSeedHash(currentSeed);
        // Apply seed-derived settings when seed changes
        applySeedSettings();
        initialize();
    });

    // Listen for hash changes (e.g., browser back/forward, manual hash change)
    window.addEventListener('hashchange', () => {
        const hash = window.location.hash.slice(1);
        if (hash) {
            const numSeed = parseInt(hash);
            currentSeed = isNaN(numSeed) ? hash : numSeed;
            seedInput.value = currentSeed.toString();
            // Apply seed-derived settings when seed changes
            applySeedSettings();
            initialize();
        }
    });

    // Initial Setup
    // Ensure URL hash is set with the initial seed
    updateSeedHash(currentSeed);
    // Apply seed-derived settings on initial load
    applySeedSettings();
    initialize();

    // Re-calculate on resize (only if width changes to avoid mobile scroll trigger)
    let lastWidth = window.innerWidth;
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            if (window.innerWidth !== lastWidth) {
                lastWidth = window.innerWidth;
                // Reorganize if currently organized, otherwise randomize
                if (isOrganized) {
                    organizePositions();
                } else {
                    randomizePositions();
                }
            }
        }, 300);
    });

    // Event Listeners
    // Tap/Click anywhere in window to toggle (Mobile & Desktop)
    window.addEventListener('click', () => {
        stopAutoCycle();
        toggleState();
        // Restart cycle after interaction to keep it alive if they stop interacting
        startAutoCycle();
    });
}
    </script>
</body>
</html>